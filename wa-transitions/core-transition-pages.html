<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link href="../../polymer/polymer.html" rel="import">
<link href="../../core-animation/web-animations.html" rel="import">
<link href="../../core-style/core-style.html" rel="import">
<link href="../../core-transition/core-transition.html" rel="import">

<!--

`core-transition-pages` represents a page transition, which may include CSS and/or
script. It will look for a `core-style` element with the same `id` to install in the
scope of the `core-animated-pages` that's using the transition.

Example:

    <core-style id="fooTransition">
        // some CSS here
    </core-style>
    <core-transition-pages id="fooTransition"></core-transition-pages>

There are three stages to a page transition:

1. `prepare`: Called to prepare the transition. This may include generating an
  animation, measuring elements, etc..

2. `go`: Called to run the transition.

3. `complete`: Called when the elements are finished transitioning.

See the individual transition documentation for specific details.

@element core-transition-pages
@status beta
@homepage github.io
-->
<!--
Fired when the transition completes.

@event core-transitionend
-->
<polymer-element name="core-transition-pages" extends="core-transition">
<script>

(function () {

// create some basic transition styling data.
var transitions = CoreStyle.g.transitions = CoreStyle.g.transitions || {};

transitions.easing = 'cubic-bezier(0.4, 0, 0.2, 1)';

transitions.duration = 500;
transitions.heroDelay = 50;
transitions.scaleDelay = 500;
transitions.cascadeFadeDuration = 250;

transitions.xfadeDelay = 5000;

var hasShadowDOMPolyfill = window.ShadowDOMPolyfill;

Polymer({

  publish: {
    targetAttribute: '',
    srcEffect: null,
    dstEffect: null,
    timing: null
  },

  prefix: '',

  config: null,

  get easing() {
    return CoreStyle.g.transitions.easing;
  },

  get duration() {
    return CoreStyle.g.transitions[this.prefix + 'Duration'] || CoreStyle.g.transitions.duration;
  },

  get delay() {
    return CoreStyle.g.transitions[this.prefix + 'Delay'] || CoreStyle.g.transitions[this.prefix + 'Duration'] || CoreStyle.g.transitions.duration;
  },

  findTargets: function(el) {
    if (!this.targetAttribute) {
      return [];
    }
    return this.findAllInShadows(el, '[' + this.targetAttribute + ']');
  },

  // carefully look into ::shadow with polyfill specific hack
  findInShadows: function(node, selector) {
    return node.querySelector(selector) || (hasShadowDOMPolyfill ? 
        Platform.queryAllShadows(node, selector) :
        node.querySelector('::shadow ' + selector));
  },

  findAllInShadows: function(node, selector) {
    if (hasShadowDOMPolyfill) {
      var nodes = node.querySelectorAll(selector).array();
      var shadowNodes = Platform.queryAllShadows(node, selector, true);
      return nodes.concat(shadowNodes);
    } else {
      return node.querySelectorAll(selector).array().concat(node.shadowRoot ? node.shadowRoot.querySelectorAll(selector).array() : []);
    }
  },

  effectForNode: function(node, isSrc) {
    return null;
  },

  timingForNode: function(node) {
    var timing = {
      duration: this.duration,
      easing: this.easing,
      fill: 'both'
    }
    if (node.hasAttribute('delay')) {
      timing.delay = parseInt(node.getAttribute('delay')) || this.delay;
    }
    return timing;
  },

  prepare: function(scope, options) {
    var anims = [];

    if (scope.hasAttribute('self')) {

      anims.push(new Animation(options.src, this.effectForNode(options.src, true), this.timingForNode(options.src)));
      anims.push(new Animation(options.dst, this.effectForNode(options.dst, false), this.timingForNode(options.dst)));

    } else {

      var targets = this.findAllInShadows(options.src, this.selector);
      targets.forEach(function(t) {
        anims.push(new Animation(t, this.effectForNode(t, true), this.timingForNode(t)));
      }.bind(this));

      targets = this.findAllInShadows(options.dst, this.selector);
      targets.forEach(function(t) {
        anims.push(new Animation(t, this.effectForNode(t, false), this.timingForNode(t)));
      }.bind(this));

      // also match the container node
      if (options.src.matches(this.selector)) {
        anims.push(new Animation(options.src, this.effectForNode(options.src, true), this.timingForNode(options.src)));
      }
      if (options.dst.matches(this.selector)) {
        anims.push(new Animation(options.dst, this.effectForNode(options.dst, false), this.timingForNode(options.dst)));
      }
    }

    if (anims.length > 1) {
      this.animation = new AnimationGroup(anims);
    } else if (anims.length === 1) {
      this.animation = anims[0];
    } else {
      this.animation = null;
    }

    return this.animation;
  },

  go: function(scope, options) {
    this.player = document.timeline.play(this.animation);
    this.player.onfinish = this.complete.bind(this, scope);
  },

  setup: function(scope) {
    // if (!scope._pageTransitionStyles) {
    //   scope._pageTransitionStyles = {};
    // }

    // var name = this.calcStyleName();
    
    // if (!scope._pageTransitionStyles[name]) {
    //   this.installStyleInScope(scope, name);
    //   scope._pageTransitionStyles[name] = true;
    // }
  },

  calcStyleName: function() {
    return this.id || this.localName;
  },

  installStyleInScope: function(scope, id) {
    if (!scope.shadowRoot) {
      scope.createShadowRoot().innerHTML = '<content></content>';
    }
    var root = scope.shadowRoot;
    var scopeStyle = document.createElement('core-style');
    root.insertBefore(scopeStyle, root.firstChild);
    scopeStyle.applyRef(id);
  },

  // ensureComplete: function(scope) {
  //   if (this.completed) {
  //     return;
  //   }
  //   this.player.finish();
  //   this.complete(scope);
  // },

  complete: function(scope) {
    this.animation = null;
    this.player = null;
    this.fire('core-transitionend', this, scope);
  }

});

})();

</script>
</polymer-element>
